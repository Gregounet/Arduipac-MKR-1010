NOTES

07/04/2024 Notes sur le fonctionnement des clocks du 8245

arduipac_vmachine.h

Chiffres valables pour NTSC:
Fréquence CPU = 5,37 MHz
Cycle instruction = 2,79 us (pourquoi ? alors que 1/(5,37*10**6) ne donne pas ça. Ca correspond à 15 cycles d'horloge
par instruction)
Fréquence VDC = 3,58 MHz
FPS = 60
262 lignes par trame (dont VBLANK = 22 et affichées = 240)
VBLANK = 22 lignes
Donc 60 * 262 = 15.720 lignes par seconde
Soit 63,61 us par ligne
Donc 22,8 cycles instruction par ligne
HBLANK = 12,32 us


Calcul précis cycles instructions par HBLANK

0.00001232 / ((1/5.370.000)*15)
0.00001232 / (15/5.370.000)
0.00001232 * (5.370.000/15)
0.00001232 * 5.370.000 / 15
5.370.000 / (60*262*15)
4.41

Calcul précis cycles instructions par ligne

(1/(60*262)) / ((1/5.370.000)*15)
(1/(60*262)) / (15/5.370.000)
(1/(60*262)) * (5.370.000/15)
5.370.000 / (60*262*15)
5.370.000 / (60*262*15)
5.370.000 / 235.800
53.700 / 2.358
22,77

Calcul précis de START_VBLCLK

(1/(60*262))*240 / ((1/5.370.000)*15)
(240/(60*262)) / (15/5.370.000)
(240/(60*262)) * (5.370.000/15)
240*5.370.000 / (60*262*15)
4*5.370.000 / (262*15)
21.480.000 / 3.930
2.148.000 / 393
5.465,64

Calcul précis de END_VBLCLK

(1/60) / ((1/5.370.000)*15)
(1/60) / (15/5.370.000)
(1/60) * (5.370.000/15)
5.370.000 / (60*15)
5.370.000 / 900
53.700 / 9
5.966,66

JE DEVRAIS UTILISER UNE ROM O2 AVEC DU NTSC

#define LINECNT 21 // Cycles instructions par ligne mais ça devrait être 22

#define START_VBLCLK 5493 // Valeur commune à NTSC et PAL mais devrait être 5466
#define END_VBLCLK 5964   // NTSC mais ça devrait être 5967
// #define END_VBLCLK   7259 // PAL

extern uint16_t vertical_clock;
extern uint16_t interrupt_clock;
extern uint16_t horizontal_clock;
extern uint8_t machine_state;

arduipac_8245.h

extern uint8_t intel8245_ram[];

// Ces deux données sont déclarées dans deux headers !

arduipac_8048.cpp

uint8_t op_cycles;
uint32_t master_counter;



Dans la boucle principale de exec_8048():

op_cycles k est mis à 1 au début et prend deux pendant la boucle principale dans le cas d instructions 
qui nécessitent deux cycles d horloge.

A la fin du cycle vertical_clock est augmenté de op_cycles (donc de 1 ou de 2).
A la fin du cycle horizontal_clock est augmenté de op_cycles (donc de 1 ou de 2).

vertical_clock contient le nombre de cycles mcu écoulés depuis le début de la trame vidéo.
horizontal_clock contient le nombre de cycles mcu écoulés depuis le début de la ligne vidéo.

master_counter sert à incrémenter itimer sous conditions:

if (timer_on)
{
    master_counter += clk;
    if (master_counter > 31)
    {
        master_counter -= 31;
        itimer++;
        if (itimer == 0x00)
        {
            timer_flag = 1;
            timer_irq();
        }
    }
}






07/04/2024 Notes sur le fonctionnement des ports du 8048

arduipac_vmachine.h

uint8_t read_p2();
void write_p1(uint8_t data);

void ext_write(uint8_t data, uint8_t addr);
uint8_t ext_read(uint8_t addr);

uint8_t in_bus();
uint8_t read_t1();



arduipac_8048.h

extern uint8_t p1, p2

arduipac_8048.cpp

uint8_t p1; // I/O Port #1
uint8_t p2; // I/O Port #2

Dans la boucle principale de exec_8048():

Les trois op-code (OUTL BUS,A ; BUS #data ; ANL BUS,#data) ne font rien (nop).
Par contre "IN A,BUS" provoque acc = in_bus().

IN A,P1 -> acc = read_p1()
IN A,P2 -> acc = p2







arduipac_input.h

void write_p1 (uint8_t data);
uint8_t read_p2 ();
uint8_t in_bus ();



07/04/2024 Notes sur le fonctionnement des interuptions

Y'a une embrouille de taille sur les Timer IRQ:

Dans la version d'origine la variable pendirq ne vaut 1 que pour trois ROM particulières (Atlantis, Block Out et Wall Street).

J'ai donc supprimé cette variable pour simplifier le code.END_VBLCLK

De cette variable dépendait tirq_pend.

Du coup celle-ci peut aussi être supprimée.

Meme chose pour xirq_pend.







Autres:

Supprimer arduipac_graphics du projet





void ext_write(uint8_t data, uint8_t addr)
{
	if (!(p1 & 0x08)) // Accessing video_ram[]
	{
#ifdef DEBUG_STDERR
		fprintf(stderr, "Accessing video_ram[0x%02X] <- 0x%02X\n", addr, data);
#endif
#ifdef DEBUG_SERIAL
		Serial.print("Accessing video_ram[0x");
		Serial.print(addr, HEX);
		Serial.print("] <- 0x");
		Serial.println(data, HEX);
#endif
#ifdef DEBUG_TFT
		text_print_string("Accessing video_ram[]");
		delay(TFT_DEBUG_DELAY);
#endif
//
#ifdef DEBUG_STDERR
		if (addr < 0x10 || (addr >= 0x80 && addr < 0xA0)) // Accessing Sprites
		{
			fprintf(stderr, "Ecriture du sprite %d.%s - [0x%02X] <- 0x%02X\n",
					((addr < 0x10) ? addr / 4 : (addr - 0x80) / 8) + 1,
					((addr >= 0x80) ? "shape"
									: ((addr % 4 == 0) ? "y"
													   : ((addr % 4 == 1) ? "x" : "attributes"))),
					addr, data);
			if (addr < 0x10)
				switch (addr % 4)
				{
				case 0:
					fprintf(stderr, "  Y = %d\n", data);
					break;
				case 1:
					fprintf(stderr, "  X = %d\n", data);
					break;
				case 2:
					fprintf(stderr, "  Color = 0x%01X, Even shift = %d, Full shift = %d\n", (data & 0x3F) >> 3, (data & 0x02) >> 1, data & 0x01);
					break;
				}
		}
		if ((addr >= 0x10) && (addr < 0x40)) // Accessing Characters
		{
			fprintf(stderr, "Ecriture du caractère %d.%s - [0x%02X] <- 0x%02X\n",
					(addr - 0x10) / 4 + 1,
					((addr - 0x10) % 4 == 0)
						? "y"
					: ((addr - 0x10) % 4 == 1) ? "x"
					: ((addr - 0x10) % 4 == 2) ? "character"
											   : "color",
					addr, data);
			switch (addr % 4)
			{
			case 0:
				fprintf(stderr, "  Y_start = %d\n", data);
				break;
			case 1:
				fprintf(stderr, "  X = %d\n", data);
				break;
			case 2:
				fprintf(stderr, "Cset pointer (lower part) = 0x%02X\n", data);
				break;
			case 3:
				fprintf(stderr, "Cset pointer (upper part) = 0x%01X, Color = 0x%01X\n", data & 0x01, (data & 0x0E) >> 1);
				cecette = ((data & 0x01) << 8) + intel8245_ram[addr - 1];
				fprintf(stderr, "CSET = 0x%03X - character = 0x%02X\n", cecette, cecette / 8);
				fprintf(stderr, "ou bien CSET = 0x%03X - character = 0x%02X\n", cecette - (intel8245_ram[addr - 3] / 2), (cecette - intel8245_ram[addr - 3] / 2) / 8);
				break;
			}
		}
		if ((addr >= 0x40) && (addr < 0x80)) // Accessing Quads
		{
			fprintf(stderr, "Ecriture du quad %d, caractère %d, %s - [0x%02X] <- 0x%02X\n",
					(addr - 0X40) / 0x10 + 1,
					(((addr - 0x40) % 0x10) / 4 + 1),
					((addr - 0x40) % 4 == 0) ? "y"
					: ((addr - 0x40) % 4 == 1)
						? "x"
					: ((addr - 0x40) % 4 == 2) ? "character"
											   : "color",
					addr, data);
			switch (addr % 4)
			{
			case 0:
				fprintf(stderr, "  Y_start = %d\n", data);
				break;
			case 1:
				fprintf(stderr, "  X = %d\n", data);
				break;
			case 2:
				fprintf(stderr, "Cset pointer (lower part) = 0x%02X\n", data);
				break;
			case 3:
				fprintf(stderr, "Cset pointer (upper part) = 0x%01X, Color = 0x%01X\n", data & 0x01, (data & 0x0E) >> 1);
				break;
				cecette = ((data & 0x01) << 8) + intel8245_ram[addr - 1];
				fprintf(stderr, "CSET = 0x%03X - character = 0x%02X\n", cecette, cecette / 8);
				fprintf(stderr, "ou bien CSET = 0x%03X - character = 0x%02X\n", cecette - (intel8245_ram[addr - 3] / 2), (cecette - intel8245_ram[addr - 3] / 2) / 8);
				break;
			}
		}
#endif
#ifdef DEBUG_SERIAL
		if (addr < 0x10 || (addr >= 0x80 && addr < 0xA0))
		{
			Serial.print("Ecriture du sprite ");
			Serial.println(((addr < 0x10) ? addr / 4 : (addr - 0x80) / 8) + 1);
		}
		if ((addr >= 0x10) && (addr < 0x40))
		{
			Serial.print("Ecriture du caractère ");
			Serial.print((addr - 0x10) / 4 + 1);
			switch ((addr - 0x10) % 4 == 0)
			{
			case 0:
				Serial.println(" y");
				break;
			case 1:
				Serial.println(" x");
				break;
			case 2:
				Serial.println(" character");
				break;
			default:
				Serial.println(" color");
				break;
			}
		}
		if ((addr >= 0x40) && (addr < 0x80))
		{
			Serial.print("Ecriture du quad ");
			Serial.print((addr - 0X40) / 0x10 + 1);
			Serial.print(" caractère ");
			Serial.print((addr - 0x10) / 4 + 1);
			switch ((addr - 0x10) % 4 == 0)
			{
			case 0:
				Serial.println(" y");
				break;
			case 1:
				Serial.println(" x");
				break;
			case 2:
				Serial.println(" character");
				break;
			default:
				Serial.println(" color");
				break;
			}
		}
	}
#endif
#ifdef DEBUG_TFT
#endif

	if (addr >= 0xA0 && addr <= 0xA3)
	{

#ifdef DEBUG_STDERR
		fprintf(stderr, "Octet de controle - [0x%02X] <- 0x%02X\n", addr, data);
#endif
#ifdef DEBUG_SERIAL
		Serial.print("Octet de controle - [0x");
		Serial.print(addr, HEX);
		Serial.print("] <- 0x");
		Serial.println(data, HEX);
#endif
#ifdef DEBUG_TFT
		text_print_string("Octet de controle - []");
		delay(TFT_DEBUG_DELAY);
#endif

		if (addr == 0xA0)
		{

#ifdef DEBUG_STDERR
			fprintf(stderr,
					"Control register: Display enable = %d, Horiz int enable = %d, Grid = %d, Fill mode = %d, Dot grid = %d, Latch position = %d\n",
					(data & 0x20) >> 5, (data & 0x01), (data & 0x08) >> 3,
					(data & 0x80) >> 7, (data & 0x40) >> 6,
					(data & 0x02) >> 1);
#endif
#ifdef DEBUG_SERIAL
			Serial.print("Control register: Display enable = ");
			Serial.print((data & 0x20) >> 5);
			Serial.print("Horiz int enable = ");
			Serial.print((data & 0x01));
			Serial.print("Grid = ");
			Serial.print((data & 0x08) >> 3);
			Serial.print("Fill mode = ");
			Serial.print((data & 0x80) >> 7);
			Serial.print("Dot grid = ");
			Serial.print((data & 0x40) >> 6);
			Serial.print("Latch position = ");
			Serial.println((data & 0x02) >> 1);
#endif
#ifdef DEBUG_TFT
			text_print_string("Control register: Display enable");
			delay(TFT_DEBUG_DELAY);
#endif

			if (intel8245_ram[0xA0] & 0x02 && !data & 0x02)
			{
				y_latch = vertical_clock / 22;
				x_latch = horizontal_clock * 12;
				if (y_latch > 241)
					y_latch = 0xFF;
			}
			/*
			 * Comme je ne comprends pas pour l'instant je commente. TODO
			if (vertical_clock <= START_VBLCLK && intel8245_ram[0xA0] != data)
				draw_display();
			*/
		}

		else if (addr == 0xA1)
		{

#ifdef DEBUG_STDERR
			fprintf(stderr, "Status register: SHOULD NOT WRITE HERE !\n");
#endif
#ifdef DEBUG_SERIAL
			Serial.print("Status register: SHOULD NOT WRITE HERE !");
#endif
#ifdef DEBUG_TFT
			text_print_string("Status register: SHOULD NOT WRITE HERE !");
			delay(TFT_DEBUG_DELAY);
#endif
		}

		else if (addr == 0xA2)
		{

#ifdef DEBUG_STDERR
			fprintf(stderr, "Collision register\n");
#endif
#ifdef DEBUG_SERIAL
			Serial.println("Collision register");
#endif
#ifdef DEBUG_TFT
			text_print_string("Collision register");
			delay(TFT_DEBUG_DELAY);
#endif
		}

		else if (addr == 0xA3)
		{

#ifdef DEBUG_STDERR
			fprintf(stderr, "Color register: Background color = 0x%1X, Grid color = 0x%1X, Grid lum = %d\n", data & 0x07, (data & 0x38) > 3, (data & 0x40) > 6);
#endif
#ifdef DEBUG_SERIAL
			Serial.print("Color register: Background color = 0x");
			Serial.print((data & 0x40) > 6, HEX);
			Serial.print(", Grid color = 0x");
			Serial.print((data & 0x38) > 3, HEX);
			Serial.print(", Grid lum = ");
			Serial.println((data & 0x40) > 6, HEX);
#endif
#ifdef DEBUG_TFT
			text_print_string("Color register: Background color");
			delay(TFT_DEBUG_DELAY);
#endif
		}
		else if (addr >= 0x40 && addr < 0x80 && addr & (0x02 == 0)) // 0x40 - 0x7F : les quatre Quads, addr & 0x02 == 0 -> les positions X et Y_start du caractère
		{															// TODO comprendre ce code

#ifdef DEBUG_STDERR
			fprintf(stderr, "Simplifying quad data\n");
#endif
#ifdef DEBUG_SERIAL
			Serial.println("Simplifying quad data");
#endif
#ifdef DEBUG_TFT
			text_print_string("Simplifying quad data");
			delay(TFT_DEBUG_DELAY);
#endif

			addr = addr & 0x71;
			if (!(addr & 0x01))
				data &= 0xFE;
			intel8245_ram[addr] = intel8245_ram[addr + 4] =
				intel8245_ram[addr + 8] = intel8245_ram[addr + 12] = data;
		}
		if (addr >= 0xA7 && addr <= 0xAA)
		{

#ifdef DEBUG_STDERR
			fprintf(stderr, "Son  - [0x%02X] <- 0x%02X\n", addr, data);
#endif
#ifdef DEBUG_SERIAL
			Serial.print("Son  - [0x");
			Serial.print(addr, HEX);
			Serial.print("] <- 0x");
			Serial.println(data, HEX);
#endif
#ifdef DEBUG_TFT
			text_print_string("Son");
			delay(TFT_DEBUG_DELAY);
#endif

			intel8245_ram[addr] = data;
		}
		// else if (!(p1 & 0x50)) // TODO: vérifier cette condition - Il est probale que je vais pouvoir transformer ceci en & 0x40
		else if (!(p1 & 0x10) && !(p1 & 0x40))
		{

#ifdef DEBUG_STDERR
			fprintf(stderr, "Accessing external_ram[0x%02X] <- 0x%02X (%s)\n", addr, data, (addr < 0x80) ? "writing" : "doing nothing");
#endif
#ifdef DEBUG_SERIAL
			Serial.print("Accessing external_ram[0x");
			Serial.print(addr, HEX);
			Serial.print("] <- 0x");
			Serial.print(data, HEX);
			Serial.println((addr < 0x80) ? " (writing)" : "(doing nothing)");
#endif

#ifdef DEBUG_TFT
#endif
		}
		if (addr < 0x80)
			external_ram[addr] = data;
	}
}

